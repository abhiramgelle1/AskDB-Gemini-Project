AskDB: SQL Query Execution Flow - Code Perspective
===================================================

This document explains the SQL query execution flow by tracing through the actual 
code, showing function calls, execution paths, and how each function interacts 
with others.

================================================================================
CODE EXECUTION FLOW - STEP BY STEP
================================================================================

1. ENTRY POINT: API Route Handler
-----------------------------------
Location: native_app.py, line 465

CODE:
    rows, execution_time, final_sql, retry_attempts = execute_sql_with_retry(
        sql, question, table_details, max_retries=2
    )

What happens:
- Calls execute_sql_with_retry() function
- Passes: SQL query string, original question, table details, max retries = 2
- Expects return: (rows, execution_time, final_sql, retry_attempts)


2. FUNCTION: execute_sql_with_retry()
--------------------------------------
Location: native_app.py, line 180-211

CODE STRUCTURE:
    def execute_sql_with_retry(sql, question, table_details, max_retries=2):
        attempts = []                    # Track all attempts
        current_sql = sql                # Start with original SQL
        
        for attempt_num in range(max_retries + 1):  # Loop: 0, 1, 2 (3 attempts)
            try:
                # ATTEMPT TO EXECUTE
                rows, execution_time = execute_sql(current_sql)
                
                # SUCCESS - return immediately
                return rows, execution_time, current_sql, attempts
                
            except Exception as e:
                # ERROR OCCURRED
                error_msg = str(e)
                
                # Record this attempt
                attempts.append({
                    "attempt": attempt_num + 1,
                    "sql": current_sql,
                    "error": error_msg
                })
                
                # Check if we can retry
                if attempt_num < max_retries:
                    # CORRECTION PHASE
                    current_sql = refine_sql(...)  # Get corrected SQL
                    # Loop continues with corrected SQL
                else:
                    # All retries exhausted
                    raise  # Re-raise the exception

EXECUTION PATH:
- First call: attempt_num = 0, current_sql = original SQL
- If error: attempt_num = 1, current_sql = corrected SQL (from refine_sql)
- If error: attempt_num = 2, current_sql = corrected SQL again
- If error: attempt_num = 3 (exceeds max_retries), raise exception


3. FUNCTION: execute_sql()
---------------------------
Location: native_app.py, line 128-150

This is the CORE function that actually executes SQL against the database.

CODE BREAKDOWN:

    def execute_sql(sql: str):
        import time
        
        # STEP 1: Start timer
        start_time = time.time()
        
        # STEP 2: Create database connection
        conn = connect_db()  # Calls connect_db() function
        
        try:
            # STEP 3: Check database type and execute
            if DB_TYPE == "sqlite":
                # SQLite execution path
                cur = conn.cursor()          # Get cursor
                cur.execute(sql)             # Execute SQL query
                rows = cur.fetchall()        # Fetch all results
                
            else:  # PostgreSQL
                import psycopg2
                with conn.cursor() as cur:   # Get cursor (auto-closes)
                    cur.execute(sql)         # Execute SQL query
                    try:
                        rows = cur.fetchall()  # Fetch all results
                    except Exception:
                        # For non-SELECT queries (INSERT/UPDATE/DELETE)
                        rows = [(f"{cur.rowcount} rows affected",)]
            
            # STEP 4: Calculate execution time
            execution_time = time.time() - start_time
            
            # STEP 5: Return results
            return rows, execution_time
            
        finally:
            # STEP 6: Always execute (even if error occurred)
            conn.commit()    # Commit transaction
            conn.close()     # Close connection

EXECUTION FLOW:
1. Record start time
2. Connect to database → connect_db()
3. Get cursor object
4. Execute SQL query (THIS IS WHERE DATABASE QUERY RUNS)
5. Fetch results (if SELECT query)
6. Calculate time taken
7. Return (rows, execution_time)
8. Finally block: commit and close connection


4. FUNCTION: connect_db()
--------------------------
Location: native_app.py, line 83-94

This function creates the database connection based on DB_TYPE.

CODE:

    def connect_db():
        if DB_TYPE == "sqlite":
            # SQLite connection
            return sqlite3.connect(DB_NAME)
        else:
            # PostgreSQL connection
            import psycopg2
            return psycopg2.connect(
                host=DB_HOST,
                port=DB_PORT,
                user=DB_USER,
                password=DB_PASSWORD,
                database=DB_NAME,
            )

EXECUTION:
- Checks environment variable DB_TYPE
- SQLite: Opens local file database
- PostgreSQL: Connects to remote database server
- Returns connection object


5. FUNCTION: refine_sql() (Called only on error)
-------------------------------------------------
Location: native_app.py, line 153-177

This function is called ONLY when execute_sql() fails. It uses LLM to correct 
the SQL query.

CODE:

    def refine_sql(question, failed_sql, error_message, table_details):
        # STEP 1: Build correction prompt
        prompt = f"""You are a SQL expert. The following query failed...
        
        Original Question: {question}
        Failed SQL Query: {failed_sql}
        Error Message: {error_message}
        
        Common Issues to Check:
        1. Column doesn't exist...
        2. Table doesn't exist...
        ...
        
        Provide ONLY the corrected SQL query, no explanations:"""
        
        # STEP 2: Call LLM to generate corrected SQL
        res = generate_content_with_retry(prompt)
        
        # STEP 3: Extract text from response
        text = res.text if hasattr(res, "text") else str(res)
        
        # STEP 4: Clean and return corrected SQL
        return clean_sql_query(text)

EXECUTION FLOW:
1. Build prompt with error details
2. Call LLM → generate_content_with_retry()
3. Get response text
4. Clean SQL → clean_sql_query()
5. Return corrected SQL string


6. FUNCTION: generate_content_with_retry()
-------------------------------------------
Location: native_app.py, line 40-80

This function handles LLM API calls with retry logic for rate limits.

CODE:

    def generate_content_with_retry(prompt, max_retries=3, initial_delay=1.0):
        last_exception = None
        
        for attempt in range(max_retries + 1):  # 0, 1, 2, 3 (4 attempts)
            try:
                # CALL LLM API
                res = model.generate_content(prompt)
                return res  # SUCCESS - return immediately
                
            except google_exceptions.ResourceExhausted as e:
                # RATE LIMIT ERROR (429)
                last_exception = e
                
                if attempt < max_retries:
                    # Calculate exponential backoff delay
                    delay = initial_delay * (2 ** attempt)  # 1s, 2s, 4s
                    
                    print(f"Rate limit hit. Retrying in {delay}s...")
                    time.sleep(delay)  # Wait before retry
                    # Loop continues
                else:
                    # All retries exhausted
                    raise Exception("API rate limit exceeded...")
                    
            except Exception as e:
                # Other errors - don't retry
                raise

EXECUTION FLOW:
1. Try to call model.generate_content(prompt)
2. If rate limit (429 error):
   - Wait: 1s (attempt 1), 2s (attempt 2), 4s (attempt 3)
   - Retry
3. If other error: raise immediately
4. If success: return response


7. FUNCTION: clean_sql_query()
-------------------------------
Location: native_app.py, line 97-108

This function cleans SQL output from LLM (removes markdown, extracts pure SQL).

CODE:

    def clean_sql_query(text: str) -> str:
        # Remove markdown code blocks: ```sql ... ```
        block_pattern = r"```(?:sql|SQL|SQLQuery|mysql|postgresql)?\s*(.*?)\s*```"
        text = re.sub(block_pattern, r"\1", text, flags=re.DOTALL)
        
        # Remove SQL prefixes like "SQLQuery:"
        prefix_pattern = r"^(?:SQL\s*Query|SQLQuery|MySQL|PostgreSQL|SQL)\s*:\s*"
        text = re.sub(prefix_pattern, "", text, flags=re.IGNORECASE)
        
        # Extract SELECT statement
        sql_statement_pattern = r"(SELECT[\s\S]*?;)"
        sql_match = re.search(sql_statement_pattern, text, flags=re.IGNORECASE)
        if sql_match:
            text = sql_match.group(1)
        
        # Remove backticks
        text = re.sub(r'`([^`]*)`', r'\1', text)
        
        # Normalize whitespace
        text = re.sub(r"\s+", " ", text).strip()
        
        return text

EXECUTION:
- Uses regex to clean SQL string
- Removes formatting artifacts
- Returns clean SQL query string


================================================================================
COMPLETE EXECUTION TRACE - EXAMPLE SCENARIO
================================================================================

SCENARIO: User asks "Show California population"
SQL Generated: SELECT COUNT(*) FROM acs_demographics WHERE "Geo_STUSAB" = 'CA'

STEP-BY-STEP CODE EXECUTION:

1. API Route Handler (line 465):
   execute_sql_with_retry(
       sql="SELECT COUNT(*) FROM acs_demographics WHERE \"Geo_STUSAB\" = 'CA'",
       question="Show California population",
       table_details="...",
       max_retries=2
   )

2. execute_sql_with_retry() - FIRST ATTEMPT (attempt_num=0):
   - current_sql = "SELECT COUNT(*) FROM acs_demographics WHERE \"Geo_STUSAB\" = 'CA'"
   - Calls: execute_sql(current_sql)
   
   3. execute_sql():
      - start_time = time.time()  # Record start
      - conn = connect_db()       # Calls connect_db()
      
      4. connect_db():
         - Checks: DB_TYPE == "postgresql"
         - Calls: psycopg2.connect(host=DB_HOST, port=DB_PORT, ...)
         - Returns: connection object
      
      - Back in execute_sql():
      - cur = conn.cursor()       # Get cursor
      - cur.execute(sql)          # EXECUTE SQL IN DATABASE (actual query runs here)
      - rows = cur.fetchall()     # Get results: [(327,)]
      - execution_time = time.time() - start_time  # e.g., 0.234 seconds
      - Return: ([(327,)], 0.234)
      
      - Finally block:
        - conn.commit()           # Commit transaction
        - conn.close()            # Close connection
   
   - Back in execute_sql_with_retry():
   - SUCCESS - returns immediately
   - Return: ([(327,)], 0.234, "SELECT COUNT(*)...", [])

5. Back to API Route Handler:
   - rows = [(327,)]
   - execution_time = 0.234
   - final_sql = "SELECT COUNT(*) FROM acs_demographics WHERE \"Geo_STUSAB\" = 'CA'"
   - retry_attempts = []


================================================================================
COMPLETE EXECUTION TRACE - ERROR SCENARIO
================================================================================

SCENARIO: SQL has error (wrong column name)
SQL Generated: SELECT wrong_column FROM acs_demographics

STEP-BY-STEP CODE EXECUTION:

1. API Route Handler (line 465):
   execute_sql_with_retry(sql="SELECT wrong_column FROM acs_demographics", ...)

2. execute_sql_with_retry() - FIRST ATTEMPT (attempt_num=0):
   - current_sql = "SELECT wrong_column FROM acs_demographics"
   - Calls: execute_sql(current_sql)
   
   3. execute_sql():
      - conn = connect_db()       # Connection successful
      - cur.execute(sql)          # EXECUTE SQL
      - EXCEPTION RAISED: column "wrong_column" does not exist
      - Exception caught in execute_sql_with_retry()
      
      - Finally block in execute_sql():
        - conn.commit()
        - conn.close()
   
   - Back in execute_sql_with_retry():
   - Exception caught: Exception("column \"wrong_column\" does not exist")
   - error_msg = "column \"wrong_column\" does not exist"
   - attempts.append({"attempt": 1, "sql": "...", "error": "..."})
   - attempt_num (0) < max_retries (2) → Can retry
   - Calls: refine_sql(...)
   
   4. refine_sql():
      - Builds prompt with error message
      - Calls: generate_content_with_retry(prompt)
      
      5. generate_content_with_retry():
         - Calls: model.generate_content(prompt)
         - LLM returns: "SELECT \"ACS23_5yr_B01001_001E\" FROM acs_demographics"
         - Returns: response object
      
      - Back in refine_sql():
      - text = response.text
      - Calls: clean_sql_query(text)
      
      6. clean_sql_query():
         - Cleans SQL string
         - Returns: "SELECT \"ACS23_5yr_B01001_001E\" FROM acs_demographics"
      
      - refine_sql() returns corrected SQL
   
   - Back in execute_sql_with_retry():
   - current_sql = "SELECT \"ACS23_5yr_B01001_001E\" FROM acs_demographics"
   - Loop continues: attempt_num = 1

2. execute_sql_with_retry() - SECOND ATTEMPT (attempt_num=1):
   - current_sql = "SELECT \"ACS23_5yr_B01001_001E\" FROM acs_demographics"
   - Calls: execute_sql(current_sql)
   
   3. execute_sql():
      - conn = connect_db()
      - cur.execute(sql)          # EXECUTE CORRECTED SQL
      - rows = cur.fetchall()     # SUCCESS! Returns results
      - Return: (rows, execution_time)
   
   - Back in execute_sql_with_retry():
   - SUCCESS - returns immediately
   - Return: (rows, execution_time, corrected_sql, attempts)

5. Back to API Route Handler:
   - rows = results from corrected SQL
   - execution_time = total time
   - final_sql = corrected SQL
   - retry_attempts = [{"attempt": 1, "sql": "...", "error": "..."}]


================================================================================
FUNCTION CALL HIERARCHY
================================================================================

NORMAL EXECUTION (SUCCESS):
---------------------------
API Route Handler
    |
    +---> execute_sql_with_retry()
          |
          +---> execute_sql()
                |
                +---> connect_db()  [Returns connection]
                |
                +---> conn.cursor()  [Gets cursor]
                |
                +---> cur.execute(sql)  [DATABASE QUERY EXECUTES HERE]
                |
                +---> cur.fetchall()  [Gets results]
                |
                +---> conn.commit()  [Commits]
                |
                +---> conn.close()  [Closes]


ERROR WITH AUTO-CORRECTION:
---------------------------
API Route Handler
    |
    +---> execute_sql_with_retry()  [Attempt 1]
          |
          +---> execute_sql()
                |
                +---> [ERROR OCCURS]
          |
          +---> refine_sql()
                |
                +---> generate_content_with_retry()
                      |
                      +---> model.generate_content()  [LLM API CALL]
                |
                +---> clean_sql_query()
          |
          +---> execute_sql()  [Attempt 2 with corrected SQL]
                |
                +---> [SUCCESS]
          |
          +---> Return results


================================================================================
KEY CODE VARIABLES AND THEIR FLOW
================================================================================

1. current_sql:
   - Starts: Original SQL from generation
   - Changes: After each refine_sql() call
   - Used: In execute_sql() to run query
   - Final: Corrected SQL (if errors occurred)

2. attempts:
   - Type: List of dictionaries
   - Contains: All failed attempts with SQL and error
   - Example:
     [
       {"attempt": 1, "sql": "...", "error": "column does not exist"},
       {"attempt": 2, "sql": "...", "error": "..."}
     ]
   - Returned: For debugging/logging purposes

3. rows:
   - Type: List of tuples (database results)
   - Example: [(327,), (450,), ...] or [('CA', 'California'), ...]
   - Returned: From execute_sql() after successful query

4. execution_time:
   - Type: Float (seconds)
   - Calculated: time.time() - start_time
   - Example: 0.234 (234 milliseconds)

5. conn (connection):
   - SQLite: sqlite3.Connection object
   - PostgreSQL: psycopg2.extensions.connection object
   - Lifecycle:
     - Created: connect_db()
     - Used: execute queries
     - Committed: conn.commit()
     - Closed: conn.close() (in finally block)

6. cur (cursor):
   - SQLite: sqlite3.Cursor object
   - PostgreSQL: psycopg2.extensions.cursor object
   - Used for:
     - cur.execute(sql) - Run query
     - cur.fetchall() - Get results
     - cur.rowcount - Get affected rows (for non-SELECT)


================================================================================
ERROR HANDLING IN CODE
================================================================================

1. Database Connection Errors:
   - Caught in: execute_sql()
   - Handled by: Exception propagates to execute_sql_with_retry()
   - Result: Triggers refine_sql() if retries available

2. SQL Execution Errors:
   - Caught in: execute_sql_with_retry() try-except block
   - Action: Record in attempts list, call refine_sql()
   - Retry: Up to max_retries times

3. LLM API Errors:
   - Rate Limits: Handled by generate_content_with_retry() with backoff
   - Other Errors: Propagate up, break refinement loop
   - Result: If refinement fails, original error is raised

4. Network/Connection Errors:
   - Caught in: execute_sql() or connect_db()
   - Handled by: Exception propagates, triggers refinement or fails

5. Finally Block Guarantees:
   - Always executes: conn.commit() and conn.close()
   - Even if: Exception occurs during query execution
   - Purpose: Prevent connection leaks


================================================================================
CODE EXECUTION TIMELINE
================================================================================

Time 0ms:   execute_sql_with_retry() called
Time 1ms:   execute_sql() called
Time 2ms:   connect_db() called
Time 5ms:   Database connection established
Time 6ms:   cur.execute(sql) called
Time 150ms: Database query completed (database processing time)
Time 151ms: cur.fetchall() called
Time 152ms: Results fetched
Time 153ms: execution_time calculated
Time 154ms: conn.commit() called
Time 155ms: conn.close() called
Time 156ms: execute_sql() returns
Time 157ms: execute_sql_with_retry() returns
Time 158ms: API handler continues

Total: ~158ms for successful execution

If Error Occurs:
Time 150ms: Exception raised in cur.execute()
Time 151ms: Exception caught in execute_sql_with_retry()
Time 152ms: refine_sql() called
Time 153ms: LLM API called
Time 2000ms: LLM response received (1-2 seconds)
Time 2001ms: clean_sql_query() called
Time 2002ms: Corrected SQL ready
Time 2003ms: execute_sql() called again with corrected SQL
Time 2150ms: Query succeeds
Total: ~2.15 seconds for error correction


================================================================================
SUMMARY: CODE EXECUTION FLOW
================================================================================

1. ENTRY: execute_sql_with_retry() called from API route
   - Input: SQL string, question, table details
   - Purpose: Execute SQL with automatic error correction

2. LOOP: Up to 3 attempts (max_retries + 1)
   - Attempt 1: Try original SQL
   - Attempt 2: Try corrected SQL (if error occurred)
   - Attempt 3: Try corrected SQL again (if still error)

3. EACH ATTEMPT:
   a. Call execute_sql(current_sql)
      - Connect to database
      - Execute SQL query
      - Fetch results
      - Return (rows, execution_time)
   
   b. If success: Return immediately
   
   c. If error:
      - Record attempt
      - Check retry limit
      - Call refine_sql() to get correction
      - Update current_sql with corrected version
      - Loop again

4. RETURN: (rows, execution_time, final_sql, attempts)
   - rows: Query results
   - execution_time: Time taken
   - final_sql: SQL that succeeded (may be corrected)
   - attempts: List of failed attempts (for debugging)

This code flow ensures:
- Automatic error recovery
- Connection cleanup (via finally block)
- Retry with intelligent corrections
- Comprehensive error tracking


